                        console.log('=== SLIDER INPUT EVENT DEBUG ===');
                        console.log('Slider value changed to:', currentValue);
                        console.log('About to call updateLikabilityColors with:', currentValue);
                        
                        updateLikabilityColors(currentValue);
                        
                        // Remove locked styling during interaction
                        this.classList.remove('locked');
                        
                        // Update value display in real-time
                        const valueDisplay = document.getElementById('likability-value');
                        if (valueDisplay) {
                            valueDisplay.textContent = currentValue;
                        }
                    }
                });
            }
        });


    // Initialize likability slider colors on page load
    document.addEventListener('DOMContentLoaded', function() {
        const likabilitySlider = document.getElementById('likability-slider');
        if (likabilitySlider) {
            const currentValue = parseInt(likabilitySlider.value) || 0;
            console.log('Page load: Initializing likability colors for value:', currentValue);
            updateLikabilityColors(currentValue);
        }
    });


        // Hook into existing likability updates
        const originalConsoleLog = console.log;
        console.log = function(...args) {
            // Check for likability update messages
            if (args[0] === 'Likability card updated:' && args[1]?.score !== undefined) {
                setTimeout(() => updateLikabilityColors(args[1].score), 100);
            }
            originalConsoleLog.apply(console, args);
        };


        // ========================================
        // HYBRID BEHAVIOR SCORING ARCHITECTURE
        // ========================================

        // Central orchestrator function
        function calculateAllBehaviorScores(patientData, activeConfig) {
            console.log("üéØ CALCULATING ALL BEHAVIOR SCORES");
            console.log("Patient Data:", patientData);
            console.log("Active Config:", activeConfig);

            const behaviors = [
                { type: "future_appointments", calculator: calculateFutureAppointments, updateCard: updateFutureAppointmentsCard },
                { type: "age_demographics", calculator: calculateAgeDemographics, updateCard: updateAgeDemographicsCard },
                { type: "yearly_spend", calculator: calculateYearlySpend, updateCard: updateYearlySpendCard },
                { type: "consecutive_attendance", calculator: calculateConsecutiveAttendance, updateCard: updateConsecutiveAttendanceCard },
                { type: "referrer_score", calculator: calculateReferrerScore, updateCard: updateReferrerScoreCard },
                { type: "cancellations", calculator: calculateCancellations, updateCard: updateCancellationsCard },
                { type: "dna", calculator: calculateDNA, updateCard: updateDNACard },
                { type: "unpaid_invoices", calculator: calculateUnpaidInvoices, updateCard: updateUnpaidInvoicesCard },
                { type: "open_dna_invoice", calculator: calculateOpenDnaInvoice, updateCard: updateOpenDnaInvoiceCard }
            ];

            let totalScore = 0;
            const behaviorScores = {};

            behaviors.forEach(behavior => {
                try {
                    const result = behavior.calculator(patientData, activeConfig);
                    behaviorScores[behavior.type] = result;
                    totalScore += result.score;

                    // Update the card display
                    behavior.updateCard(result);

                    console.log(`‚úÖ ${behavior.type}: ${result.score} points - ${result.status}`);
                } catch (error) {
                    console.error(`‚ùå Error calculating ${behavior.type}:`, error);
                }
            });

            // Update total score and rating
            updateTotalScoreAndRating(totalScore, behaviorScores);

            return { totalScore, behaviorScores };
        }

        // ========================================
        // INDIVIDUAL BEHAVIOR CALCULATORS
        // ========================================

        // üìÖ Future Appointments Calculator
        function calculateFutureAppointments(patientData, activeConfig) {
            const hasAppointments = patientData.behavior_data?.future_appointments?.has_appointments || false;
            const appointmentsCount = patientData.behavior_data?.future_appointments?.count || 0;
            const weight = activeConfig.future_appointments_weight || 0;

            const score = hasAppointments ? weight : 0;
            const status = `${appointmentsCount} future appointments`;

            return { score, status, hasAppointments, appointmentsCount };
        }

        // üë§ Age Demographics Calculator (placeholder)
        function calculateAgeDemographics(patientData, activeConfig) {
            // TODO: Implement age bracket logic
            return { score: 0, status: "Age calculation pending" };
        }

        // üí∞ Yearly Spend Calculator (placeholder)
        function calculateYearlySpend(patientData, activeConfig) {
            // TODO: Implement spend bracket logic
            return { score: 0, status: "Spend calculation pending" };
        }

        // ‚úÖ Consecutive Attendance Calculator (placeholder)
        function calculateConsecutiveAttendance(patientData, activeConfig) {
            // TODO: Implement attendance streak logic
            return { score: 0, status: "Attendance calculation pending" };
        }

        // üë• Referrer Score Calculator (placeholder)
        function calculateReferrerScore(patientData, activeConfig) {
            // TODO: Implement referrer logic
            return { score: 0, status: "Referrer calculation pending" };
        }

        // ‚ùå Cancellations Calculator (placeholder)
        function calculateCancellations(patientData, activeConfig) {
            // TODO: Implement cancellations logic
            return { score: 0, status: "Cancellations calculation pending" };
        }

        // üö´ DNA Calculator (placeholder)
        function calculateDNA(patientData, activeConfig) {
            // TODO: Implement DNA logic
            return { score: 0, status: "DNA calculation pending" };
        }

        // üí∏ Unpaid Invoices Calculator (placeholder)
        function calculateUnpaidInvoices(patientData, activeConfig) {
            // TODO: Implement unpaid invoices logic
            return { score: 0, status: "Unpaid invoices calculation pending" };
        }

        // üí≥ Open DNA Invoice Calculator (placeholder)
        function calculateOpenDnaInvoice(patientData, activeConfig) {
            // TODO: Implement open DNA invoice logic
            return { score: 0, status: "Open DNA calculation pending" };
        }

        // ========================================
        // TOTAL SCORE AND RATING UPDATE
        // ========================================

        function updateTotalScoreAndRating(totalScore, behaviorScores) {
            // Update total score display
            const scoreElement = document.getElementById("total-score");
            if (scoreElement) {
                scoreElement.textContent = Math.round(totalScore);
            }

            // Calculate and update letter grade
            const letterGrade = calculateLetterGrade(totalScore);
            const ratingElement = document.getElementById("letter-rating");
            if (ratingElement) {
                ratingElement.textContent = letterGrade;
            }

            console.log(`üìä TOTAL SCORE: ${totalScore} (${letterGrade})`);
        }

        function calculateLetterGrade(score) {
            if (score >= 100) return "A+";
            if (score >= 80) return "A";
            if (score >= 60) return "B";
            if (score >= 40) return "C";
            if (score >= 20) return "D";
            return "F";
        }


    // Global variables for Calculate button functionality
    let selectedPatientId = null;
    let selectedPatientName = null;

    // Function to store patient when selected from search results
    function selectPatientForCalculation(patientId, patientName) {
        selectedPatientId = patientId;
        selectedPatientName = patientName;
        
        // Enable calculate button
        const calculateBtn = document.getElementById('calculate-btn');
        if (calculateBtn) {
            calculateBtn.disabled = false;
            calculateBtn.style.opacity = '1';
        }
        
        console.log(`‚úÖ Patient selected for calculation: ${patientName} (ID: ${patientId})`);
    }

    // Calculate button function - reuses existing load_patient_behavior logic
    function calculatePatientScores() {
        if (!window.currentPatientId) {
            alert('Please search for a patient and select one first by clicking on their name.');
            return;
        }

        const calculateBtn = document.getElementById('calculate-btn');
        
        // Show loading state
        calculateBtn.textContent = 'Calculating...';
        calculateBtn.disabled = true;

        console.log(`üîÑ Calculating scores for patient ${window.currentPatientId} (${selectedPatientName}) with current config`);

        // Use existing load_patient_behavior AJAX endpoint
        fetch(`/patients/${window.currentPatientId}/dashboard-score/`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                'X-Requested-With': 'XMLHttpRequest'
            },
            // body: removed for GET request
        })
        .then(response => response.json())
        .then(data => {
            calculateBtn.disabled = false;
            calculateBtn.textContent = 'Calculate';
            
            if (data.success) {
                console.log('‚úÖ Patient scores calculated successfully');
                console.log(`üìä Total Score: ${data.score}, Grade: ${data.grade}`);

                // UPDATE ALL BEHAVIOR CARDS (same as loadPatientBehaviorData)
                if (data.behavior_data) {
                    updateOpenDnaInvoiceCard(data.behavior_data.open_dna_invoices);
                    updateUnpaidInvoicesCard(data.behavior_data.unpaid_invoices);
                    updateDNACard(data.behavior_data.dna);
                    updateFutureAppointmentsCard(data.behavior_data.future_appointments);
                    updateAgeDemographicsCard(data.behavior_data.age_demographics);
                    updateYearlySpendCard(data.behavior_data.yearly_spend);
                    updateConsecutiveAttendanceCard(data.behavior_data.consecutive_attendance);
                    updateReferrerScoreCard(data.behavior_data.referrer_score);
                    updateCancellationsCard(data.behavior_data.cancellations);
                    updateLikabilityCard(data.behavior_data.likability);

                    // UPDATE SCORE DISPLAY
                    if (data.score !== undefined && data.grade !== undefined) {
                        const scoreDisplay = `${Math.round(data.score)}/${data.grade}`;
                        document.getElementById('patient-score-display').textContent = scoreDisplay;
                        console.log('‚úÖ SCORE DISPLAY UPDATED:', scoreDisplay);
                    }
                }
                
                // Show success feedback
                calculateBtn.textContent = '‚úÖ Calculated!';
                calculateBtn.style.background = '#198754';
                
                // Reset button after 2 seconds
                setTimeout(() => {
                    calculateBtn.textContent = 'Calculate';
                    calculateBtn.style.background = '#28a745';
                }, 2000);
            } else {
                console.error('‚ùå Calculation error:', data.error);
                alert('Error calculating patient scores: ' + data.error);
            }
        })
        .catch(error => {
            calculateBtn.disabled = false;
            calculateBtn.textContent = 'Calculate';
            console.error('‚ùå Network error:', error);
            alert('Network error occurred while calculating scores.');
        });
    }

    // Initialize calculate button as disabled on page load
    document.addEventListener('DOMContentLoaded', function() {
        const calculateBtn = document.getElementById('calculate-btn');
        if (calculateBtn) {
            calculateBtn.disabled = true;
            calculateBtn.style.opacity = '0.6';
        }
    });


(function() {
    // Prevent multiple initializations
    if (window.settingsHoverPanelInitialized) return;
    window.settingsHoverPanelInitialized = true;

    // Centralized event setup function
    function setupSettingsHoverPanel() {
        const settingsTrigger = document.getElementById('settings-trigger');
        const settingsHoverPanel = document.getElementById('settings-hover-panel');
        const panelCloseBtn = settingsHoverPanel.querySelector('.hover-panel-close');

        // Remove any existing global handlers
        if (window.settingsTriggerHandler) {
            settingsTrigger.removeEventListener('click', window.settingsTriggerHandler);
        }
        if (window.panelCloseBtnHandler) {
            panelCloseBtn.removeEventListener('click', window.panelCloseBtnHandler);
        }
        if (window.outsideClickHandler) {
            document.removeEventListener('click', window.outsideClickHandler);
        }
        if (window.keydownHandler) {
            document.removeEventListener('keydown', window.keydownHandler);
        }

        // Define global handlers to allow precise removal
        window.settingsTriggerHandler = function(event) {
            event.stopPropagation();
            settingsHoverPanel.classList.toggle('open');
        };

        window.panelCloseBtnHandler = function() {
            settingsHoverPanel.classList.remove('open');
        };

        window.outsideClickHandler = function(event) {
            if (settingsHoverPanel.classList.contains('open') && 
                event.target !== settingsTrigger) {
                settingsHoverPanel.classList.remove('open');
            }
        };

        window.keydownHandler = function(event) {
            if (event.key === 'Escape' && settingsHoverPanel.classList.contains('open')) {
                settingsHoverPanel.classList.remove('open');
            }
        };

        // Add single, definitive event listeners
        settingsTrigger.addEventListener('click', window.settingsTriggerHandler);
        panelCloseBtn.addEventListener('click', window.panelCloseBtnHandler);
        document.addEventListener('click', window.outsideClickHandler);
        document.addEventListener('keydown', window.keydownHandler);
    }

    // Use DOMContentLoaded to ensure elements exist
    document.addEventListener('DOMContentLoaded', setupSettingsHoverPanel);
})();

</script>

<div id=settings-hover-panel class=settings-hover-panel>
    <div class=hover-panel-content>
        <h2>RatedApp Settings</h2>
        <section class="settings-section clinic-information">
            <h3>Clinic Information</h3>
            <div class="form-group clinic-name">
                <label for="clinic-name">Name:</label>
                <input type="text" id="clinic-name" name="clinic_name" placeholder="Enter clinic name">
            </div>
            <div class="form-group clinic-location">
                <label for="clinic-location">Location:</label>
                <input type="text" id="clinic-location" name="clinic_location" placeholder="Suburb">
            </div>
            <div class="form-group clinic-timezone">
    <label for="clinic-timezone">Timezone:</label>
    <select id="clinic-timezone" name="clinic_timezone">
        <option value="">Select Timezone</option>
        <option value="Australia/Sydney">Australia/Sydney (AEST)</option>
        <option value="Australia/Melbourne">Australia/Melbourne (AEST)</option>
        <option value="Australia/Brisbane">Australia/Brisbane (AEST)</option>
        <option value="Australia/Perth">Australia/Perth (AWST)</option>
        <option value="Australia/Adelaide">Australia/Adelaide (ACST)</option>
    </select>
    <span class="edit-save-text" data-form-group="clinic-information">Edit</span>
</div>
        </section>
        <div class="section-separator" style="width: 100%; height: 1px; background-color: #e0e0e0; margin: 15px 0;"></div>
        <section class="settings-section connectivity-settings">
            <h3>Connectivity</h3>
        
            <div class="form-group software-integration">
                <label for="software-integration">Software:</label>
                <select id="software-integration" name="software_integration" disabled required>
                    <option value="">Select Software</option>
                    <option value="cliniko">Cliniko</option>
                </select>
            </div>

            <div class="form-group api-key">
                <label for="api-key">API Key:</label>
                <input type="text" id="api-key" name="api_key" disabled placeholder="Enter API key" required>
                <span class="edit-save-text" data-form-group="connectivity">Edit</span>
            </div>
</section>
        <div class="section-separator section-separator-2" style="width: 100%; height: 1px; background-color: #e0e0e0; margin: 15px 0;"></div>
        <h3>Analytics</h3>


    </div>
    <div class="hover-panel-close" aria-label="Close Settings">√ó</div>
</div>

        </section>

        </div>
</div>




    <script>
    // Function to load clinic settings
    function loadClinicSettings() {
    fetch('/update-clinic-settings/')
    .then(response => {
        if (!response.ok) {
            throw new Error('No settings found');
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            const settings = data.settings;
            
            // Populate Clinic Information
            document.getElementById('clinic-name').value = settings.clinic_information.clinic_name;
            document.getElementById('clinic-location').value = settings.clinic_information.clinic_location;
            document.getElementById('clinic-timezone').value = settings.clinic_information.clinic_timezone;
            
            // Populate Connectivity
const softwareSelect = document.getElementById('software-integration');
const apiKeyInput = document.getElementById('api-key');
const apiKeyFormGroup = document.querySelector('.form-group.api-key');

softwareSelect.value = settings.connectivity.software_integration || '';

// Show masked API key and connection status if API key exists
if (settings.connectivity.api_key && settings.connectivity.api_key !== 'None') {
    apiKeyInput.value = settings.connectivity.api_key; // Shows masked key (****1234)
    
    const statusElement = document.createElement('div');
    statusElement.classList.add('connection-status', 'connected');
    statusElement.textContent = 'Connected';
    apiKeyFormGroup.appendChild(statusElement);
}
        }
    })
    .catch(error => {
        console.error('Error loading settings:', error);
    });
}

    // Call on page load
    document.addEventListener('DOMContentLoaded', loadClinicSettings);
    
// Add CSS for Edit/Save text and input states
const style = document.createElement("style");
style.textContent = `
    .form-group {
        position: relative;
        display: flex;
        align-items: baseline;
    }

    .edit-save-text {
        color: #6c757d;
        font-size: 0.9em;
        cursor: pointer;
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        user-select: none;
    }

    .edit-save-text.save-mode {
        color: #007bff;
    }

    .validation-error {
        color: red;
        margin-left: 5px;
    }

    /* Consistent disabled state for all inputs */
    input:disabled, select:disabled {
        opacity: 0.6;
        background-color: #f8f9fa;
        cursor: not-allowed;
    }

    /* Remove focus outline on all inputs */
    input:focus, select:focus {
        outline: none;
        box-shadow: none;
        border-color: #ced4da;
    }
`;
document.head.appendChild(style);

// Find the Clinic Information section
const clinicInformationSection = document.querySelector(".settings-section.clinic-information");
const formGroups = clinicInformationSection.querySelectorAll(".form-group");
const timezoneFormGroup = document.querySelector(".form-group.clinic-timezone");
const clinicNameInput = document.querySelector("#clinic-name");

// Get the existing Edit/Save span
const editSaveSpan = timezoneFormGroup.querySelector(".edit-save-text");

// Interaction Logic
    editSaveSpan.addEventListener("click", (event) => {
        event.preventDefault();
        event.stopPropagation();

        console.log("Current Span State:", {
            text: editSaveSpan.textContent,
            classes: Array.from(editSaveSpan.classList)
        });

        // EDIT MODE (when NOT in save mode)
        if (!editSaveSpan.classList.contains("save-mode")) {
            console.log("üîß Entering Edit Mode");
            editSaveSpan.textContent = "Save";
            editSaveSpan.classList.add("save-mode");
            
            formGroups.forEach(group => {
                const input = group.querySelector("input, select");
                if (input) {
                    input.disabled = false;
                    console.log(`Enabled input: ${input.id}`);
                }
            });

            // Focus on first field (Name) and position cursor at end
            setTimeout(() => {
                clinicNameInput.focus();
                clinicNameInput.setSelectionRange(
                    clinicNameInput.value.length, 
                    clinicNameInput.value.length
                );
            }, 10);
        } 
        // SAVE MODE
        else {
            const inputs = Array.from(
                clinicInformationSection.querySelectorAll("input, select")
            );
            
            // Remove previous validation errors
            clinicInformationSection.querySelectorAll(".validation-error").forEach(el => el.remove());

            // Validate critical inputs
            const invalidInputs = inputs.filter(input => !input.value.trim());

            console.log("üïµÔ∏è Validation Check:", {
                totalInputs: inputs.length,
                invalidInputs: invalidInputs.map(input => input.id)
            });

            if (invalidInputs.length > 0) {
                console.log("‚ùå Validation Failed");
                
                invalidInputs.forEach(input => {
                    const formGroup = input.closest(".form-group");
                    if (formGroup) {
                        const errorSpan = document.createElement("span");
                        errorSpan.classList.add("validation-error");
                        errorSpan.textContent = "*";
                        formGroup.appendChild(errorSpan);
                    }
                });
                return;
            }

            // Successful Save Logic
            console.log("‚úÖ Save Successful");
            editSaveSpan.textContent = "Edit";
            editSaveSpan.classList.remove("save-mode");
            
            // Disable all inputs
            formGroups.forEach(group => {
                const input = group.querySelector("input, select");
                if (input) {
                    input.disabled = true;
                    console.log(`Disabled input: ${input.id}`);
                }
            });

            // Capture save data
            const saveData = {
                clinic_name: document.getElementById("clinic-name").value,
                clinic_location: document.getElementById("clinic-location").value,
                clinic_timezone: document.querySelector("#clinic-timezone").value
            };
            
            console.log("üíæ Clinic Settings Updated:", saveData);

saveSettings('clinic_information', saveData)
    .then(result => {
        console.log("Settings saved successfully");
    })
    .catch(error => {
        console.error("Error saving settings:", error);
    });

            document.getElementById('clinic-name-header').textContent = saveData.clinic_name;
            document.getElementById('clinic-location-header').textContent = saveData.clinic_location;


        }
    });

// Initially disable all inputs
formGroups.forEach(group => {
    const input = group.querySelector("input, select");
    input.disabled = true;
});

console.log("‚úÖ Edit/Save Interaction Setup Complete");

</script>

<script>
// CSRF Token Retrieval
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Unified Save Mechanism
function saveSettings(section, data) {
    return fetch('/update-clinic-settings/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            section: section,
            ...data
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Save failed');
        }
        return response.json();
    })
    .then(result => {
        if (result.success) {
            console.log(`${section} settings saved successfully`);
            return result;
        } else {
            throw new Error(result.error || 'Save failed');
        }
    })
    .catch(error => {
        console.error(`Error saving ${section} settings:`, error);
        alert(`Failed to save ${section} settings: ${error.message}`);
        throw error;
    });
}

// Connectivity Edit/Save Logic
document.addEventListener('DOMContentLoaded', function() {
    const connectivitySection = document.querySelector(".settings-section.connectivity-settings");
    const editSaveSpan = connectivitySection.querySelector(".edit-save-text");
    const softwareSelect = document.getElementById('software-integration');
    const apiKeyInput = document.getElementById('api-key');
    const apiKeyFormGroup = document.querySelector('.form-group.api-key');

    // Clear any existing status messages
    function clearStatusMessages() {
        const existingStatusElements = apiKeyFormGroup.querySelectorAll('.connection-status');
        existingStatusElements.forEach(el => el.remove());
    }

    // Create status message
    function createStatusMessage(message, type) {
        clearStatusMessages();
        const statusElement = document.createElement('div');
        statusElement.classList.add('connection-status', type);
        statusElement.textContent = message;
        apiKeyFormGroup.appendChild(statusElement);
    }

    editSaveSpan.addEventListener("click", function() {
        if (this.textContent === 'Edit') {
            // EDIT MODE
            clearStatusMessages();
            softwareSelect.disabled = false;
            apiKeyInput.disabled = false;
            
            this.textContent = 'Save';
            this.classList.add('save-mode');
        } else {
            // SAVE MODE
            const saveData = {
                software_integration: softwareSelect.value,
                api_key: apiKeyInput.value
            };

            // Show spinner and enforce 3-second minimum delay
showAPIValidationSpinner();
const startTime = Date.now();

validateClinikoAPIKey(saveData.api_key)
    .then(async (validationResult) => {
        // Ensure minimum 3-second delay
        const elapsedTime = Date.now() - startTime;
        const remainingTime = Math.max(0, 3000 - elapsedTime);
        await new Promise(resolve => setTimeout(resolve, remainingTime));
        
        hideAPIValidationSpinner();
        
        if (validationResult.status === 'Connected') {
            // Successful validation - save to backend
            createStatusMessage('Connected', 'connected');
            
            return saveSettings('connectivity', {
                software_integration: saveData.software_integration,
                api_key: saveData.api_key
            });
        } else {
            // Validation failed - don't save to backend
            createStatusMessage(validationResult.error, 'disconnected');
            
            // Keep fields unlocked and in Save mode
            softwareSelect.disabled = false;
            apiKeyInput.disabled = false;
            this.textContent = 'Save';
            this.classList.add('save-mode');
            
            throw new Error(validationResult.error);
        }
    })
    .then(() => {
        // Successful save - lock fields and return to Edit mode
        softwareSelect.disabled = true;
        apiKeyInput.disabled = true;
        
        this.textContent = 'Edit';
        this.classList.remove('save-mode');
    })
    .catch(error => {
        console.error('Connectivity Save Error:', error);
        hideAPIValidationSpinner();
        
        // Revert to Edit state
        this.textContent = 'Edit';
        this.classList.remove('save-mode');
        
        // LOCK inputs (Edit state has locked fields)
        softwareSelect.disabled = true;
        apiKeyInput.disabled = true;
    });
        }
    });
});

async function validateClinikoAPIKey(apiKey) {
    const validationUrl = `/validate-cliniko-api-key/?api_key=${encodeURIComponent(apiKey)}`;
    
    try {
        const response = await fetch(validationUrl);
        const result = await response.json();

        if (response.ok) {
            return {
                status: 'Connected',
                message: result.message
            };
        } else {
            return {
                status: 'Disconnected',
                error: result.error || 'Invalid API key'
            };
        }
    } catch (error) {
        console.error('API Validation Error:', error);
        return {
            status: 'Disconnected',
            error: 'Network Error'
        };
    }
}

// UI Helper Functions
function showAPIValidationSpinner() {
    const apiKeyField = document.getElementById('api-key');
    const spinnerElement = document.createElement('span');
    spinnerElement.classList.add('api-validation-spinner');
    spinnerElement.innerHTML = '‚è≥'; // Loading spinner emoji
    apiKeyField.parentNode.appendChild(spinnerElement);
}

function hideAPIValidationSpinner() {
    const spinner = document.querySelector('.api-validation-spinner');
    if (spinner) spinner.remove();
}

// Update saveSettings to use API validation
function saveSettings(section, data) {
    // Existing save logic for other sections
    return fetch('/update-clinic-settings/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            section: section,
            ...data
        })
    });
}

// Add CSS for connection status
const connectionStatusStyle = document.createElement('style');
connectionStatusStyle.textContent = `
    .connection-status {
        margin-left: 10px;
        font-size: 0.8em;
        font-weight: bold;
    }
    .connection-status.connected {
        color: green;
    }
    .connection-status.disconnected {
        color: red;
    }
    .api-validation-spinner {
        margin-left: 10px;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        100% { transform: rotate(360deg); }
    }
`;
document.head.appendChild(connectionStatusStyle);

</script>

</body>
</html>
