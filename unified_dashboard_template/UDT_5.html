                        
                        if (valueElement && data.preset[field] !== undefined) {
                            valueElement.textContent = data.preset[field];
                            console.log(`‚úÖ Updated slider value ${field}: ${data.preset[field]}`);
                        }
                        
                        if (sliderElement && data.preset[field] !== undefined) {
                            sliderElement.value = data.preset[field];
                            console.log(`‚úÖ Updated slider input ${field}: ${data.preset[field]}`);
                        }
                    });
                    
                    console.log("‚úÖ All slider values updated from preset data");
                } else {
                    console.log("‚ùå No preset data available for points/brackets update");
                }
            
            // DEBUG: Log the complete AJAX response data
            console.log('üîç DEBUG: Complete AJAX response data:', JSON.stringify(data, null, 2));
            console.log('üîç DEBUG: data.preset exists?', !!data.preset);
            console.log('üîç DEBUG: data.config exists?', !!data.config); // Legacy debug - data.config deprecated
            if (data.preset) {
                console.log('üîç DEBUG: data.preset.future_appointments_weight:', data.preset.future_appointments_weight);
                console.log('üîç DEBUG: data.preset.open_dna_invoice_weight:', data.preset.open_dna_invoice_weight);
            
            }
            
            // Update all slider values from the response
            if (data.preset) {
                // Update weight sliders
                // FIXED: Use correct approach - simple vs complex sliders
                const simpleSliders = [
                    {field: 'future_appointments_weight', sliderName: 'future_appointments_weight'},
                    {field: 'age_demographics_weight', sliderName: 'age_demographics_weight'},
                    {field: 'yearly_spend_weight', sliderName: 'yearly_spend_weight'},
                    {field: 'consecutive_attendance_weight', sliderName: 'consecutive_attendance_weight'},
                    {field: 'referrer_score_weight', sliderName: 'referrer_score_weight'}
                ];
                
                const complexSliders = [
                    {field: 'cancellations_weight', displayId: 'cancellations_weight_value'},
                    {field: 'dna_weight', displayId: 'dna_weight_value'},
                    {field: 'unpaid_invoices_weight', displayId: 'unpaid_invoices_weight_value'},
                    {field: 'open_dna_invoice_weight', displayId: 'open_dna_invoice_weight_value'}
                ];
                
                // Update points fields
                const points = {
                    'points-per-consecutive-attendance': data.preset.points_per_consecutive_attendance,
                    'points-per-referral': data.preset.points_per_referral,
                    'points-per-cancellation': data.preset.points_per_cancellation,
                    'points-per-dna': data.preset.points_per_dna,
                    'points-per-unpaid-invoice': data.preset.points_per_unpaid_invoice
                };
                
                // FIXED: Handle simple and complex sliders differently
                
                // Update simple sliders (first 4) - just update slider value, display updates automatically
                simpleSliders.forEach(mapping => {
                    const slider = document.querySelector(`input[name='${mapping.sliderName}']`);
                    const value = data.preset[mapping.field];
                    
                    if (slider && value !== undefined) {
                        slider.value = value;
                        // Trigger the oninput event to update display
                        slider.dispatchEvent(new Event('input'));
                        console.log(`‚úÖ Updated simple slider ${mapping.field}: ${value}`);
                            
                // All slider updates completed successfully
                console.log('applyPresetById completed for preset ID:');
            } else {
                        console.warn(`‚ùå Failed to update simple slider ${mapping.field}:`, {slider: !!slider, value});
                    }
                });
                
                // Update complex sliders (last 4) - update both slider and display element
                complexSliders.forEach(mapping => {
                    const slider = document.querySelector(`input[name='${mapping.field}']`);
                    const display = document.getElementById(mapping.displayId);
                    const value = data.preset[mapping.field];
                    
                    if (slider && display && value !== undefined) {
                        slider.value = value;
                        display.textContent = value;
                        console.log(`‚úÖ Updated complex slider ${mapping.field}: ${value}`);
                            
                // All slider updates completed successfully
                console.log('applyPresetById completed for preset ID:');
            } else {
                        console.warn(`‚ùå Failed to update complex slider ${mapping.field}:`, {slider: !!slider, display: !!display, value});
                    }
                });
                
                // Apply points values
                Object.entries(points).forEach(([fieldId, value]) => {
                    const field = document.getElementById(fieldId);
                    if (field) {
                        field.value = value;
                    }
                });
                
                console.log('All slider and points values updated from preset:', presetName);
            }
                
                // All slider updates completed successfully
                console.log('applyPresetById completed for preset ID:');
            } else {
            console.error('Failed to apply preset:', data.error);
        }
    })
    .catch(error => {
        console.error('Error applying preset:', error);
    });
    

}

// Function to show inline success message (like Update Preset success)
function showInlineSuccessMessage(message) {
    console.log('Showing inline success message:', message);
    
    // Find the update button to show success message next to it
    const updateButton = document.getElementById('update-preset-btn');
    if (updateButton) {
        // Remove any existing success messages
        const existingSuccess = updateButton.parentElement.querySelector('.success-message');
        if (existingSuccess) {
            existingSuccess.remove();
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            const appliedPresetName = null; // localStorage persistence disabled
            if (appliedPresetName) {
                updatePresetHeader(appliedPresetName);
                console.log('Restored header to show applied preset:', appliedPresetName);
            }
            
            // Screen values loaded from database via Django template (localStorage persistence removed)
            // const persistenceData = null; // localStorage persistence disabled
            if (false) {
                try {
                    const data = null; // localStorage persistence disabled
                    console.log('Restoring comprehensive persistence data:', data);
                    
                    // Restore all 8 slider values
                    if (data.sliders) {
                        Object.keys(data.sliders).forEach(sliderName => {
                            const slider = document.querySelector('input[name="' + sliderName + '"]');
                            // Try pattern without _weight first (for first 4 sliders)
                            let valueDisplay = document.getElementById(sliderName.replace('_weight', '') + '_value');
                            // If not found, try pattern with _weight (for last 4 sliders)  
                            if (!valueDisplay) {
                                valueDisplay = document.getElementById(sliderName + '_value');
                            }
                            if (slider && data.sliders[sliderName]) {
                                slider.value = data.sliders[sliderName];
                                if (valueDisplay) {
                                    valueDisplay.textContent = data.sliders[sliderName];
                                }
                                console.log('Restored slider:', sliderName, '=', data.sliders[sliderName]);
                            }
                        });
                    }
                    
                    // Restore all 4 points display values
                    if (data.points) {
                        Object.keys(data.points).forEach(pointsId => {
                            const display = document.getElementById(pointsId);
                            const inputId = pointsId.replace('-points-display', '-input');
                            const hiddenId = pointsId.replace('-points-display', '-hidden');
                            const input = document.getElementById(inputId);
                            const hidden = document.getElementById(hiddenId);
                            
                            if (display && data.points[pointsId]) {
                                display.textContent = data.points[pointsId];
                                if (input) input.value = data.points[pointsId];
                                if (hidden) hidden.value = data.points[pointsId];
                                console.log('Restored points:', pointsId, '=', data.points[pointsId]);
                            }
                        });
                    }
                    
                    // Restore age brackets
                    if (data.ageBrackets && data.ageBrackets.length > 0) {
                        const ageBracketsContainer = document.getElementById('age-brackets-content');
                        if (ageBracketsContainer) {
                            // Clear existing brackets (keep only the + ADD button)
                            const addButton = ageBracketsContainer.querySelector('button[onclick*="addNewAgeBracket"]');
                            ageBracketsContainer.innerHTML = '';
                            
                            // Create container div
                            const containerDiv = document.createElement('div');
                            containerDiv.style.cssText = 'display: flex; gap: 8px; align-items: flex-start; flex-wrap: wrap;';
                            
                            // Add restored brackets with complete structure including delete buttons
                            data.ageBrackets.forEach(bracketText => {
                                const bracketDiv = document.createElement('div');
                                bracketDiv.style.cssText = 'display: flex; flex-direction: column; align-items: flex-start;';
                                
                                // Parse bracket text (e.g., "18-25 20%")
                                const parts = bracketText.trim().split(/\s+/);
                                const rangeText = parts[0]; // "18-25"
                                const percentageText = parts[parts.length - 1]; // "20%"
                                
                                bracketDiv.innerHTML = '<div style="display: flex; border: 1px solid #dee2e6; border-radius: 3px; background: white; font-size: 0.8rem;"><div style="padding: 4px 8px; border-right: 1px solid #dee2e6; font-weight: 500;">' + rangeText + '</div><div style="padding: 4px 8px; background: #f8f9fa; font-weight: 600; color: #007bff;">' + percentageText + '</div></div><div style="display: flex; gap: 4px; margin-top: 2px;"><button onclick="deleteAgeBracket(\'restored-\' + Math.random().toString(36).substr(2, 9))" style="background: #dc3545; color: white; border: none; padding: 2px 6px; border-radius: 2px; font-size: 0.7rem; cursor: pointer;">Delete</button></div>';
                                containerDiv.appendChild(bracketDiv);
                            });
                            
                            // Re-add the + ADD button
                            if (addButton) {
                                containerDiv.appendChild(addButton);
                            }
                            
                            ageBracketsContainer.appendChild(containerDiv);
                            console.log('Restored age brackets:', data.ageBrackets.length, 'brackets');
                        }
                    }
                    
                    // Restore spend brackets
                    if (data.spendBrackets && data.spendBrackets.length > 0) {
                        const spendBracketsContainer = document.getElementById('spend-brackets-content');
                        if (spendBracketsContainer) {
                            // Clear existing brackets (keep only the + ADD button)
                            const addButton = spendBracketsContainer.querySelector('button[onclick*="addNewSpendBracket"]');
                            spendBracketsContainer.innerHTML = '';
                            
                            // Create container div
                            const containerDiv = document.createElement('div');
                            containerDiv.style.cssText = 'display: flex; gap: 8px; align-items: flex-start; flex-wrap: wrap;';
                            
                            // Add restored brackets with complete structure including delete buttons
                            data.spendBrackets.forEach(bracketText => {
                                const bracketDiv = document.createElement('div');
                                bracketDiv.style.cssText = 'display: flex; flex-direction: column; align-items: flex-start;';
                                
                                // Parse bracket text (e.g., "0-500 15%")
                                const parts = bracketText.trim().split(/\s+/);
                                const rangeText = parts[0]; // "0-500"
                                const percentageText = parts[parts.length - 1]; // "15%"
                                
                                bracketDiv.innerHTML = '<div style="display: flex; border: 1px solid #dee2e6; border-radius: 3px; background: white; font-size: 0.8rem;"><div style="padding: 4px 12px; border-right: 1px solid #dee2e6; font-weight: 500; min-width: 85px; text-align: center;">' + rangeText + '</div><div style="padding: 4px 8px; background: #f8f9fa; font-weight: 600; color: #007bff;">' + percentageText + '</div></div><div style="display: flex; gap: 4px; margin-top: 2px;"><button onclick="deleteSpendBracket(\'restored-\' + Math.random().toString(36).substr(2, 9))" style="background: #dc3545; color: white; border: none; padding: 2px 6px; border-radius: 2px; font-size: 0.7rem; cursor: pointer;">Delete</button></div>';
                                containerDiv.appendChild(bracketDiv);
                            });
                            
                            // Re-add the + ADD button
                            if (addButton) {
                                containerDiv.appendChild(addButton);
                            }
                            
                            spendBracketsContainer.appendChild(containerDiv);
                            console.log('Restored spend brackets:', data.spendBrackets.length, 'brackets');
                        }
                    }
                    
                    console.log('Complete persistence restoration finished');
                    
                } catch (error) {
                    console.error('Error restoring persistence data:', error);
                }
                    
                // All slider updates completed successfully
                console.log('applyPresetById completed for preset ID:');
            } else {
                console.log('No persistence data found in localStorage');
            }
        });
// Make bracket functions globally accessible
window.addNewAgeBracket = addNewAgeBracket;
window.addNewSpendBracket = addNewSpendBracket;
window.deleteAgeBracket = deleteAgeBracket;
window.deleteSpendBracket = deleteSpendBracket;
}
    }

// ===========================================
// PATIENT CARDS JAVASCRIPT FUNCTIONS
// ===========================================

// Global variable to store current patient ID
window.currentPatientId = null;

// Search Patients Function
function searchPatients() {
    const searchTerm = document.getElementById('patient-search-input').value.trim();
    if (searchTerm.length < 2) {
        alert('Please enter at least 2 characters to search');
        return;
    }
    
    // Show loading state
    const searchBtn = document.getElementById('search-patient-btn');
    const originalText = searchBtn.textContent;
    searchBtn.textContent = 'Searching...';
    searchBtn.disabled = true;
    
    // AJAX search request
    fetch('/patients/dashboard/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
            'X-Requested-With': 'XMLHttpRequest'
        },
        body: `action=search_patients&search_term=${encodeURIComponent(searchTerm)}`
    })
    .then(response => response.json())
    .then(data => {
        displaySearchResults(data.patients || []);
        searchBtn.textContent = originalText;
        searchBtn.disabled = false;
    })
    .catch(error => {
        console.error('Search error:', error);
        searchBtn.textContent = originalText;
        searchBtn.disabled = false;
        alert('Search failed. Please try again.');
    });
}

// Display Search Results Function
function displaySearchResults(patients) {
    const resultsContainer = document.getElementById('search-results-container');
    const resultsList = document.getElementById('search-results-list');
    const resultsCount = document.getElementById('results-count');
    
    resultsCount.textContent = patients.length;
    
    if (patients.length === 0) {
        resultsList.innerHTML = '<div style="padding: 12px; text-align: center; color: #666; font-size: 0.85rem;">No patients found</div>';
    } else {
        resultsList.innerHTML = patients.map(patient => `
            <div class="search-result-item" style="padding: 8px 12px; border-bottom: 1px solid #f0f0f0; cursor: pointer; font-size: 0.85rem; width: 100%;" 
                 onclick="selectPatient(${patient.id}, '${patient.name.replace(/'/g, "\'")}')">
                <span style="font-weight: 500;">${patient.name}</span>
                <span style="color: #666; font-size: 0.75rem;">ID: ${patient.id}</span>
            </div>
        `).join('');
    }
    
    resultsContainer.style.display = 'block';
}

// Select Patient Function
function selectPatient(patientId, patientName) {
    // Update selected patient header
    document.getElementById('selected-patient-name').textContent = patientName;

    // Enable Calculate button when patient is selected
    const calculateBtn = document.getElementById('calculate-btn');
    if (calculateBtn) {
        calculateBtn.disabled = false;
        calculateBtn.style.opacity = '1';
        console.log('‚úÖ Calculate button enabled for patient:', patientName);
    }
    document.getElementById('selected-patient-id').textContent = `ID: ${patientId}`;
    document.getElementById('selected-patient-header').style.display = 'block';
    
    // Hide search results
    document.getElementById('search-results-container').style.display = 'none';
    
    // Show behavior cards container
    document.getElementById('behavior-cards-container').style.display = 'block';
    
    // Store current patient ID
    window.currentPatientId = patientId;
    
    // Load patient behavior data
    loadPatientBehaviorData(patientId);
    
    // Load behavior data for all cards when patient is selected
    console.log('Loading behavior data for patient:', patientId);

    
    // Display patient score
    displayPatientScore(patientId);
}

// Load Patient Behavior Data Function

// Update Likability Slider
function updateLikabilitySlider(value) {
    document.getElementById('likability-slider').value = value;
    document.getElementById('likability-value').textContent = value;
}


// Likability Edit/Save Functions
function editLikability() {
    console.log('=== EDIT LIKABILITY DEBUG ===');
    
    const slider = document.getElementById('likability-slider');
    const editBtn = document.getElementById('edit-likability-btn');
    const saveBtn = document.getElementById('save-likability-btn');
    
    console.log('Slider before edit:', slider.disabled, slider.className);
    console.log('Current slider value:', slider.value);
    
    slider.disabled = false;
    editBtn.style.display = 'none';
    saveBtn.style.display = 'inline-block';
    
    // Apply dynamic colors based on current slider value
    const currentValue = parseInt(slider.value) || 0;
    updateLikabilityColors(currentValue);
    
    // Remove locked state styling
    slider.classList.remove('locked');
}

function saveLikability() {
    const value = document.getElementById('likability-slider').value;
    const patientId = window.currentPatientId;
    
    if (!patientId) {
        alert('No patient selected');
        return;
    }
    
    fetch('/patients/dashboard/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
            'X-Requested-With': 'XMLHttpRequest'
        },
        body: `action=update_likability&patient_id=${patientId}&likability=${value}`
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            document.getElementById('likability-slider').disabled = true;
            // Reset slider colors to grey (locked state)
            document.getElementById('likability-slider').style.setProperty('--slider-track-color', '#adb5bd');
            document.getElementById('likability-slider').style.setProperty('--slider-thumb-color', '#adb5bd');
            document.getElementById('edit-likability-btn').style.display = 'inline-block';
            document.getElementById('save-likability-btn').style.display = 'none';
            document.getElementById('likability-value').textContent = value;
        }
    })
    .catch(error => {
        console.error('Likability save error:', error);
    });
}



// Update slider values when sliders are moved
document.addEventListener('DOMContentLoaded', function() {
    // Add event listeners for slider value updates
    const likabilitySlider = document.getElementById('likability-slider');
    if (likabilitySlider) {
        likabilitySlider.addEventListener('input', function() {
            document.getElementById('likability-value').textContent = this.value;
        });
    }
    
});

// ===========================================
// END PATIENT CARDS JAVASCRIPT FUNCTIONS
// ===========================================


// Open DNA Invoice Card Integration
function loadPatientBehaviorData(patientId) {
    if (!patientId) {
        console.log('No patient ID provided');
        return;
    }
    
    // Show loading state
    const dnaCard = document.querySelector('.compact-behavior-card:has([style*="üìã Open DNA Invoices"])');
    if (dnaCard) {
        dnaCard.style.opacity = '0.6';
    }
    
    // Make AJAX request to load patient behavior data
    fetch(`/patients/${patientId}/dashboard-score/`, {
        method: 'GET',
        headers: {
            'X-Requested-With': 'XMLHttpRequest'
        },
    })
    .then(response => response.json())
    .then(data => {
        if (data.success && data.behavior_data) {
            updateOpenDnaInvoiceCard(data.behavior_data.open_dna_invoices);
            updateUnpaidInvoicesCard(data.behavior_data.unpaid_invoices);
            updateDNACard(data.behavior_data.dna);
            updateFutureAppointmentsCard(data.behavior_data.future_appointments);
            updateAgeDemographicsCard(data.behavior_data.age_demographics);
            updateYearlySpendCard(data.behavior_data.yearly_spend);
            updateConsecutiveAttendanceCard(data.behavior_data.consecutive_attendance);
            updateReferrerScoreCard(data.behavior_data.referrer_score);
            updateCancellationsCard(data.behavior_data.cancellations);
            updateCancellationsCard(data.behavior_data.cancellations);
            updateLikabilityCard(data.behavior_data.likability);
            
            // UPDATE SCORE DISPLAY (ELIMINATES NEED FOR DUPLICATE AJAX)
            if (data.score !== undefined && data.grade !== undefined) {
                const scoreDisplay = `${Math.round(data.score)}/${data.grade}`;
                document.getElementById('patient-score-display').textContent = scoreDisplay;
                console.log('‚úÖ SCORE DISPLAY UPDATED:', scoreDisplay);
            }
        } else {
            console.error('Failed to load behavior data:', data.error);
        }
    })
    .catch(error => {
        console.error('Error loading patient behavior:', error);
    })
    .finally(() => {
        // Remove loading state
        if (dnaCard) {
            dnaCard.style.opacity = '1';
        }
    });
}

function updateOpenDnaInvoiceCard(dnaData) {
    // Use getElementById pattern like PatientAnalysisView - clean and reliable
    const descriptionSpan = document.querySelector('#open-dna-invoices-card span[style*="color: #666"]');
    const pointsElement = document.getElementById('open-dna-score');
    
    if (descriptionSpan && dnaData.description) {
        descriptionSpan.textContent = dnaData.description;
    }
    
    if (pointsElement && dnaData.points !== undefined) {
        pointsElement.textContent = dnaData.points.toString();
    }
}
function updateUnpaidInvoicesCard(data) {
    const descriptionSpan = document.querySelector('#unpaid-invoices-card span[style*="color: #666"]');
    const pointsElement = document.getElementById('unpaid-invoices-score');
    
    if (descriptionSpan && data.description) {
        descriptionSpan.textContent = data.description;
    }
    
    if (pointsElement && data.points !== undefined) {
        pointsElement.textContent = data.points.toString();
    }
}
function updateDNACard(data) {
    const descriptionSpan = document.querySelector('#dna-card span[style*="color: #666"]');
    const pointsElement = document.getElementById('dna-score');
    
    if (descriptionSpan && data.description) {
        descriptionSpan.textContent = data.description;
    }
    
    if (pointsElement && data.points !== undefined) {
        pointsElement.textContent = data.points.toString();
    }
}
function updateCancellationsCard(data) {
    const descriptionSpan = document.querySelector('#cancellations-card span[style*="color: #666"]');
    const pointsElement = document.getElementById('cancellations-score');
    
    if (descriptionSpan && data.description) {
        descriptionSpan.textContent = data.description;
    }
    
    if (pointsElement && data.points !== undefined) {
        pointsElement.textContent = data.points.toString();
    }
}
function updateReferrerScoreCard(data) {
    const descriptionSpan = document.querySelector('#referrer-score-card span[style*="color: #666"]');
    const pointsElement = document.getElementById('referrer-score');
    
    if (descriptionSpan && data.description) {
        descriptionSpan.textContent = data.description;
    }
    
    if (pointsElement && data.points !== undefined) {
        pointsElement.textContent = data.points.toString();
    }
}
function updateConsecutiveAttendanceCard(data) {
    const descriptionSpan = document.querySelector('#consecutive-attendance-card span[style*="color: #666"]');
    const pointsElement = document.getElementById('consecutive-attendance-score');
    
    if (descriptionSpan && data.description) {
        descriptionSpan.textContent = data.description;
    }
    
    if (pointsElement && data.points !== undefined) {
        pointsElement.textContent = data.points.toString();
    }
}
function updateYearlySpendCard(data) {
    const descriptionSpan = document.querySelector('#yearly-spend-card span[style*="color: #666"]');
    const pointsElement = document.getElementById('yearly-spend-score');
    
    if (descriptionSpan && data.description) {
        descriptionSpan.textContent = data.description;
    }
    
    if (pointsElement && data.points !== undefined) {
        pointsElement.textContent = data.points.toString();
    }
}
function updateAgeDemographicsCard(data) {
    const descriptionSpan = document.querySelector('#age-demographics-card span[style*="color: #666"]');
    const pointsElement = document.getElementById('age-demographics-score');
    
    if (descriptionSpan && data.description) {
        descriptionSpan.textContent = data.description;
    }
    
    if (pointsElement && data.points !== undefined) {
        pointsElement.textContent = data.points.toString();
    }
}
function updateFutureAppointmentsCard(data) {
    const descriptionSpan = document.querySelector('#future-appointments-card span[style*="color: #666"]');
    const pointsElement = document.getElementById('future-appointments-score');
    
    if (descriptionSpan && data.description) {
        descriptionSpan.textContent = data.description;
    }
    
    if (pointsElement && data.points !== undefined) {
        pointsElement.textContent = data.points.toString();
    }
}
function updateCancellationsCard(data) {
    const descriptionSpan = document.querySelector('#cancellations-card span[style*="color: #666"]');
    const pointsElement = document.getElementById('cancellations-score');
    
    if (descriptionSpan && data.description) {
        descriptionSpan.textContent = data.description;
    }
    
    if (pointsElement && data.points !== undefined) {
        pointsElement.textContent = data.points.toString();
    }
}

function updateLikabilityCard(data) {
    const descriptionSpan = document.querySelector('#likability-card span[style*="color: #666"]');
    const pointsElement = document.getElementById('likability-score');
    
    if (descriptionSpan && data.description) {
        descriptionSpan.textContent = data.description;
    }
    
    if (pointsElement && data.points !== undefined) {
        pointsElement.textContent = data.points.toString();
    }
    
    // SET SLIDER VALUE FROM LOADED DATA - FIX FOR PER-PATIENT LOADING
    if (data && data.points !== undefined) {
        document.getElementById('likability-slider').value = data.points;
        document.getElementById('likability-value').textContent = data.points;
        updateLikabilityColors(data.points); // ‚úÖ ADD COLOR UPDATE ON LOAD
        console.log('‚úÖ LOADED LIKABILITY SLIDER VALUE:', data.points);
    } else {
        console.log('‚ùå NO LIKABILITY POINTS DATA:', data);
    }
}


// Hook into existing patient search functionality
// This will be called when a patient is selected
function onPatientSelected(patientId) {
    console.log('Patient selected:', patientId);
}


        function editReferrerPoints() {
    document.getElementById("referrer-points-display").style.display = "none";
    document.getElementById("edit-referrer-btn").style.display = "none";
    document.getElementById("referrer-input").style.display = "inline";
    document.getElementById("save-referrer-btn").style.display = "inline-block";
    document.getElementById("referrer-input").focus();
}


        function saveReferrerPoints() {
    const newValue = document.getElementById("referrer-input").value;
    if (newValue < 0 || newValue > 100) return;
    
    // Screen-only updates - NO AJAX CALL
    document.getElementById("referrer-points-display").textContent = newValue;
    document.getElementById("referrer-hidden").value = newValue;
    document.getElementById("referrer-points-display").style.display = "inline";
    document.getElementById("edit-referrer-btn").style.display = "inline-block";
    document.getElementById("referrer-input").style.display = "none";
    document.getElementById("save-referrer-btn").style.display = "none";
}
    
(function() {
    // Prevent multiple initializations
    if (window.settingsHoverPanelInitialized) return;
    window.settingsHoverPanelInitialized = true;

    // Centralized event setup function
    function setupSettingsHoverPanel() {
        const settingsTrigger = document.getElementById('settings-trigger');
        const settingsHoverPanel = document.getElementById('settings-hover-panel');
        const panelCloseBtn = settingsHoverPanel.querySelector('.hover-panel-close');

        // Remove any existing global handlers
        if (window.settingsTriggerHandler) {
            settingsTrigger.removeEventListener('click', window.settingsTriggerHandler);
        }
        if (window.panelCloseBtnHandler) {
            panelCloseBtn.removeEventListener('click', window.panelCloseBtnHandler);
        }
        if (window.outsideClickHandler) {
            document.removeEventListener('click', window.outsideClickHandler);
        }
        if (window.keydownHandler) {
            document.removeEventListener('keydown', window.keydownHandler);
        }

        // Define global handlers to allow precise removal
        window.settingsTriggerHandler = function(event) {
            event.stopPropagation();
            settingsHoverPanel.classList.toggle('open');
        };

        window.panelCloseBtnHandler = function() {
            settingsHoverPanel.classList.remove('open');
        };

    window.outsideClickHandler = function(event) {
        const settingsHoverPanel = document.getElementById('settings-hover-panel');
        const settingsTrigger = document.getElementById('settings-trigger');
        
        // Check if panel is open
        if (settingsHoverPanel.classList.contains('open')) {
            // Check if click is outside panel and not on settings trigger
            if (!settingsHoverPanel.contains(event.target) && 
                event.target !== settingsTrigger) {
                settingsHoverPanel.classList.remove('open');
            }
        }
    };

        window.keydownHandler = function(event) {
            if (event.key === 'Escape' && settingsHoverPanel.classList.contains('open')) {
                settingsHoverPanel.classList.remove('open');
            }
        };

        // Add single, definitive event listeners
        settingsTrigger.addEventListener('click', window.settingsTriggerHandler);
        panelCloseBtn.addEventListener('click', window.panelCloseBtnHandler);
        document.addEventListener('click', window.outsideClickHandler);
        document.addEventListener('keydown', window.keydownHandler);
    }

    // Use DOMContentLoaded to ensure elements exist
    document.addEventListener('DOMContentLoaded', setupSettingsHoverPanel);
})();

</script>

<script>
// Add Enter key functionality to search input
document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('patient-search-input');
    if (searchInput) {
        searchInput.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' || event.keyCode === 13) {
                event.preventDefault(); // Prevent form submission
                searchPatients(); // Trigger search function
            }
        });
    }
});

function displayPatientScore(patientId) {
    // Score display now handled by loadPatientBehaviorData() - no duplicate AJAX needed
    if (!patientId) {
        document.getElementById('patient-score-display').textContent = '---/--';
        return;
    }
    
    // Function kept for compatibility but AJAX removed to eliminate duplicate requests
    console.log('displayPatientScore called for patient:', patientId, '(score updated by loadPatientBehaviorData)');
}

        // Likability Dynamic Colors - Clean Implementation
        function getLikabilityColor(value) {
            if (value > 0) return '#28a745';      // Green for positive
            if (value < 0) return '#dc3545';      // Red for negative
            return '#007bff';                     // Blue for neutral
        }

        function getLikabilityEmoji(value) {
            if (value > 0) return 'ü•≥';           // Party for positive
            if (value < 0) return 'ü§¨';           // Angry for negative
            return 'üòä';                          // Smile for neutral
        }

        function updateLikabilityColors(score) {
            const slider = document.getElementById('likability-slider');
            const header = slider?.closest('.compact-behavior-card')?.querySelector('span');
            const valueDisplay = document.getElementById('likability-value');
            
            if (!slider || !header || !valueDisplay) return;
            
            const color = getLikabilityColor(score);
            const emoji = getLikabilityEmoji(score);

            // DEBUG: Log all slider color operations
            console.log('=== SLIDER COLOR DEBUG ===');
            console.log('Score:', score);
            console.log('Color:', color);
            console.log('Slider disabled:', slider.disabled);
            console.log('Slider classes before:', slider.className);
            
            // Log current CSS custom properties
            const computedStyle = getComputedStyle(slider);
            console.log('Current --slider-track-color:', slider.style.getPropertyValue('--slider-track-color'));
            console.log('Current --slider-thumb-color:', slider.style.getPropertyValue('--slider-thumb-color'));
            
            
            // Update header emoji and color
            header.textContent = emoji + ' Likability';
            header.style.color = color;
            
            // Update value color
            valueDisplay.style.color = color;
            
            // Update slider colors based on edit state
            if (slider.disabled) {
                // Locked state: always grey
                slider.classList.add('locked');
                slider.style.setProperty('--slider-track-color', '#adb5bd');
                slider.style.setProperty('--slider-thumb-color', '#adb5bd');
            } else {
                // Edit state: use dynamic colors
                slider.classList.remove('locked');
                slider.style.setProperty('--slider-track-color', color);
                slider.style.setProperty('--slider-thumb-color', color);
            }
        }
        // Add real-time color updates during slider interaction
        document.addEventListener('DOMContentLoaded', function() {
            const likabilitySlider = document.getElementById('likability-slider');
            if (likabilitySlider) {
                likabilitySlider.addEventListener('input', function() {
                    // Only update colors if slider is enabled (in edit mode)
                    if (!this.disabled) {
                        const currentValue = parseInt(this.value) || 0;

