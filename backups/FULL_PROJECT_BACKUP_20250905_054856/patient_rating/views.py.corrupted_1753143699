from django.views.decorators.csrf import csrf_exempt
import json
from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponseRedirect
from django.views import View
from django.contrib import messages
from django.urls import reverse
from django.db.models import F
from django.db import models, IntegrityError, transaction
import requests
import base64
import time
from .models import ScoringConfiguration, Patient, AgeBracket, SpendBracket
from .utils.patient_analyzer import analyze_patient_behavior

# Cliniko API Configuration
RAW_API_KEY = "MS0xNzIwNjExOTk1MjMwNjY3Nzk4LWJieWZXTDBvV2w5L1pYOFVsK3hsRlFPeHlocmhkbVRw-au1"
ENCODED_API_KEY = base64.b64encode(f"{RAW_API_KEY}:".encode()).decode()
BASE_URL = "https://api.au1.cliniko.com/v1"
HEADERS = {
    'Authorization': f'Basic {ENCODED_API_KEY}',
    'Accept': 'application/json',
    'User-Agent': 'RatedApp Patient Search'
}

class HomeView(View):
    def get(self, request):
        return render(request, 'patient_rating/home.html')

class PatientSearchView(View):
    def get(self, request):
        return render(request, 'patient_rating/patient_search.html')
    
    def post(self, request):
        search_type = request.POST.get('search_type', 'name')
        search_value = request.POST.get('search_value', '').strip()
        
        if not search_value:
            return render(request, 'patient_rating/patient_search.html', {
                'error': 'Please enter a search value'
            })
        
        try:
            if search_type == 'name':
                patients = self.search_by_name(search_value)
            elif search_type == 'id':
                patients = self.search_by_id(search_value)
            else:
                patients = []
            
            return render(request, 'patient_rating/patient_search.html', {
                'patients': patients,
                'search_value': search_value,
                'search_type': search_type
            })
        except Exception as e:
            return render(request, 'patient_rating/patient_search.html', {
                'error': f'Search failed: {str(e)}'
            })
    
    def get_phone_numbers(self, patient):
        phone_numbers = patient.get('patient_phone_numbers', [])
        if not phone_numbers:
            return "Not provided"
        formatted_phones = []
        for phone in phone_numbers:
            number = phone.get('number', '')
            phone_type = phone.get('phone_type', '')
            if number:
                formatted_phones.append(f"{number} ({phone_type})")
        return " | ".join(formatted_phones) if formatted_phones else "Not provided"
    
    def search_by_name(self, name):
        name_parts = name.split(' ', 1)
        first_name = name_parts[0]
        url = f"{BASE_URL}/patients"
        params = {'q[]': f'first_name:={first_name}'}
        response = requests.get(url, headers=HEADERS, params=params)
        response.raise_for_status()
        data = response.json()
        patients = data.get('patients', [])
        formatted_patients = []
        for patient in patients:
            phone = self.get_phone_numbers(patient)
            formatted_patients.append({
                'id': patient.get('id'),
                'first_name': patient.get('first_name'),
                'last_name': patient.get('last_name'),
                'email': patient.get('email'),
                'phone': phone,
                'date_of_birth': patient.get('date_of_birth'),
                'full_name': f"{patient.get('first_name', '')} {patient.get('last_name', '')}".strip()
            })
        return formatted_patients
    
    def search_by_id(self, patient_id):
        url = f"{BASE_URL}/patients/{patient_id}"
        response = requests.get(url, headers=HEADERS)
        response.raise_for_status()
        patient = response.json()
        phone = self.get_phone_numbers(patient)
        return [{
            'id': patient.get('id'),
            'first_name': patient.get('first_name'),
            'last_name': patient.get('last_name'),
            'email': patient.get('email'),
            'phone': phone,
            'date_of_birth': patient.get('date_of_birth'),
            'full_name': f"{patient.get('first_name', '')} {patient.get('last_name', '')}".strip()
        }]

class PatientAnalysisView(View):
    def get(self, request, patient_id):
        return render(request, 'patient_rating/patient_analysis.html', {
            'patient_id': patient_id
        })
    
    def post(self, request, patient_id):
        try:
            # Get active scoring configuration for dynamic weights
            config = ScoringConfiguration.get_active_config()
            analysis = analyze_patient_behavior(patient_id, config)
            
            if analysis:
                return JsonResponse({
                    'status': 'success',
                    'analysis': analysis
                })
            else:
                return JsonResponse({
                    'status': 'error',
                    'message': 'Analysis failed'
                })
        except Exception as e:
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            })

class UpdateLikabilityView(View):
    def post(self, request):
        try:
            data = json.loads(request.body)
            patient_id = data.get('patient_id')
            likability_value = int(data.get('likability', 0))
            
            # Get or create patient record
            patient, created = Patient.objects.get_or_create(
                cliniko_patient_id=patient_id,
                defaults={'patient_name': f'Patient {patient_id}'}
            )
            
            # Update likability value
            patient.likability = likability_value
            patient.save()
            
            return JsonResponse({'success': True})
            
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})

class UpdateUnlikabilityView(View):
    def post(self, request):
        try:
            data = json.loads(request.body)
            patient_id = data.get('patient_id')
            unlikability_value = int(data.get('unlikability', 0))
            
            # Get or create patient record
            patient, created = Patient.objects.get_or_create(
                cliniko_patient_id=patient_id,
                defaults={'patient_name': f'Patient {patient_id}'}
            )
            
            # Update unlikability value
            patient.unlikability = unlikability_value
            patient.save()
            
            return JsonResponse({'success': True})
            
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})

def unified_dashboard(request):
    if request.method == "POST":
        try:
            active_config = ScoringConfiguration.objects.get(is_active=True)
            action = request.POST.get('action')
            
            # Handle age bracket operations
            if action == 'delete_age_bracket':
                bracket_id = request.POST.get('bracket_id')
                if bracket_id:
                    bracket = get_object_or_404(AgeBracket, id=bracket_id)
                    bracket.delete()
                    if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                        return JsonResponse({"success": True})
            
            elif action == 'add_age_bracket':
                print("DEBUG: add_age_bracket action triggered")
                min_age = request.POST.get('min_age')
                max_age = request.POST.get('max_age')
                percentage = request.POST.get('percentage')
                
                if min_age and max_age and percentage:
                    try:
                        new_min_age = int(min_age)
                        new_max_age = int(max_age)
                        new_percentage = int(percentage)
                        
                        print(f"DEBUG: Values - min_age: {new_min_age}, max_age: {new_max_age}, percentage: {new_percentage}")
                        
                        # Simple approach: just add with next available order
                        max_order = AgeBracket.objects.filter(
                            config=active_config
                        ).aggregate(max_order=models.Max('order'))['max_order'] or 0
                        
                        print(f"DEBUG: Creating bracket with order {max_order + 1}")
                        
                        # Create new bracket
                        AgeBracket.objects.create(
                            config=active_config,
                            min_age=new_min_age,
                            max_age=new_max_age,
                            percentage=new_percentage,
                            order=max_order + 1
                        )
                        
                        print("DEBUG: Bracket created successfully")
                        
                        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                            return JsonResponse({"success": True})
                            
                    except Exception as e:
                        print(f"DEBUG: Error creating bracket: {e}")
                        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                            return JsonResponse({"success": False, "error": str(e)})

            # Handle spend bracket operations
            elif action == 'delete_spend_bracket':
                bracket_id = request.POST.get('bracket_id')
                if bracket_id:
                    bracket = get_object_or_404(SpendBracket, id=bracket_id)
                    bracket.delete()
                    if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                        return JsonResponse({"success": True})
            
            elif action == 'add_spend_bracket':
                print("DEBUG: add_spend_bracket action triggered")
                min_spend = request.POST.get('min_spend')
                max_spend = request.POST.get('max_spend')
                percentage = request.POST.get('percentage')
                
                if min_spend and max_spend and percentage:
                    try:
                        new_min_spend = float(min_spend)
                        new_max_spend = float(max_spend)
                        new_percentage = int(percentage)
                        
                        print(f"DEBUG: Values - min_spend: {new_min_spend}, max_spend: {new_max_spend}, percentage: {new_percentage}")
                        
                        # Simple approach: just add with next available order
                        max_order = SpendBracket.objects.filter(
                            config=active_config
                        ).aggregate(max_order=models.Max('order'))['max_order'] or 0
                        
                        print(f"DEBUG: Creating spend bracket with order {max_order + 1}")
                        
                        # Create new bracket
                        SpendBracket.objects.create(
                            config=active_config,
                            min_spend=new_min_spend,
                            max_spend=new_max_spend,
                            percentage=new_percentage,
                            order=max_order + 1
                        )
                        
                        print("DEBUG: Spend bracket created successfully")
                        
                        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                            return JsonResponse({"success": True})
                            
                    except Exception as e:
                        print(f"DEBUG: Error creating spend bracket: {e}")
                        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                            return JsonResponse({"success": False, "error": str(e)})
            
            # Handle weight updates

            # Handle Unpaid Invoices points update
            elif action == 'update_unpaid_invoices_points':
                points_value = request.POST.get('points_per_unpaid_invoice')
                if points_value:
                    try:
                        points_int = int(points_value)
                        if 1 <= points_int <= 100:
                            active_config.points_per_unpaid_invoice = points_int
                            active_config.save()
                            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                                return JsonResponse({"success": True})
                        else:
                            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                                return JsonResponse({"success": False, "error": "Points must be between 1 and 100"})
                    except ValueError:
                        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                            return JsonResponse({"success": False, "error": "Invalid points value"})
                    except Exception as e:
                        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                            return JsonResponse({"success": False, "error": str(e)})


            # Handle DNA points update
            elif action == 'update_dna_points':
                points_value = request.POST.get('points_per_dna')
                if points_value:
                    try:
                        points_int = int(points_value)
                        if 1 <= points_int <= 100:
                            active_config.points_per_dna = points_int
                            active_config.save()
                            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                                return JsonResponse({"success": True})
                        else:
                            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                                return JsonResponse({"success": False, "error": "Points must be between 1 and 100"})
                    except ValueError:
                        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                            return JsonResponse({"success": False, "error": "Invalid points value"})
                    except Exception as e:
                        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                            return JsonResponse({"success": False, "error": str(e)})


            # Handle cancellations points update
            elif action == 'update_cancellations_points':
                points_value = request.POST.get('points_per_cancellation')
                if points_value:
                    try:
                        points_int = int(points_value)
                        if 1 <= points_int <= 100:
                            active_config.points_per_cancellation = points_int
                            active_config.save()
                            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                                return JsonResponse({"success": True})
                        else:
                            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                                return JsonResponse({"success": False, "error": "Points must be between 1 and 100"})
                    except ValueError:
                        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                            return JsonResponse({"success": False, "error": "Invalid points value"})
                    except Exception as e:
                        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                            return JsonResponse({"success": False, "error": str(e)})


            # Handle consecutive attendance points update
            elif action == 'update_consecutive_points':
                points_value = request.POST.get('points_per_consecutive_attendance')
                if points_value:
                    try:
                        points_int = int(points_value)
                        if 1 <= points_int <= 100:
                            active_config.points_per_consecutive_attendance = points_int
                            active_config.save()
                            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                                return JsonResponse({"success": True})
                        else:
                            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                                return JsonResponse({"success": False, "error": "Points must be between 1 and 100"})
                    except ValueError:
                        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                            return JsonResponse({"success": False, "error": "Invalid points value"})
                    except Exception as e:
                        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                            return JsonResponse({"success": False, "error": str(e)})

            else:
                active_config.future_appointments_weight = int(request.POST.get("future_appointments_weight", active_config.future_appointments_weight))
                active_config.age_demographics_weight = int(request.POST.get("age_demographics_weight", active_config.age_demographics_weight))
                active_config.yearly_spend_weight = int(request.POST.get("yearly_spend_weight", active_config.yearly_spend_weight))
                active_config.consecutive_attendance_weight = int(request.POST.get("consecutive_attendance_weight", active_config.consecutive_attendance_weight))
                active_config.cancellations_weight = int(request.POST.get("cancellations_weight", active_config.cancellations_weight))
                active_config.dna_weight = int(request.POST.get("dna_weight", active_config.dna_weight))
                active_config.unpaid_invoices_weight = int(request.POST.get("unpaid_invoices_weight", active_config.unpaid_invoices_weight))
                active_config.open_dna_invoice_weight = int(request.POST.get("open_dna_invoice_weight", active_config.open_dna_invoice_weight))
                active_config.save()
                
                if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                    return JsonResponse({"success": True})
                    
                return HttpResponseRedirect(reverse("unified_dashboard"))
                
        except Exception as e:
            if request.headers.get("X-Requested-With") == "XMLHttpRequest":
                return JsonResponse({"success": False, "error": str(e)})

            pass
    
    # GET request - display the dashboard
    try:
        active_config = ScoringConfiguration.objects.get(is_active=True)
        age_brackets = AgeBracket.objects.filter(config=active_config).order_by('min_age')
        spend_brackets = SpendBracket.objects.filter(config=active_config).order_by('min_spend')
    except ScoringConfiguration.DoesNotExist:
        active_config = None
        age_brackets = []
        spend_brackets = []
    
        # Get all presets for dropdown
    all_presets = ScoringConfiguration.objects.all().order_by('name')
    
    context = {
        'active_config': active_config,
        'age_brackets': age_brackets,
        'spend_brackets': spend_brackets,
        'all_presets': all_presets,
    }
    
    return render(request, 'patient_rating/unified_dashboard.html', context)


@csrf_exempt
def delete_preset(request):
    if request.method == 'POST':
        try:
            preset_id = request.POST.get('preset_id')
            if not preset_id:
                return JsonResponse({'success': False, 'error': 'No preset ID provided'})
            
            # Get and delete the preset
            preset = ScoringConfiguration.objects.get(id=preset_id)
            preset_name = preset.name
            preset.delete()
            
            return JsonResponse({
                'success': True, 
                'message': f'Preset "{preset_name}" deleted successfully'
            })
            
        except ScoringConfiguration.DoesNotExist:
            return JsonResponse({'success': False, 'error': 'Preset not found'})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    
    return JsonResponse({'success': False, 'error': 'Invalid request method'})